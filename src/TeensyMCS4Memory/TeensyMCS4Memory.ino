//
// TeensyMCS4Memory.ino
// Memory System for MCS-4 using Teensy 4.1
// May 5, 2023
// by Ryo Mukai
//

#define min(x, y) (((x)<(y)) ? (x): (y))
#define max(x, y) (((x)>(y)) ? (x): (y))

#define MCLK_MHz   5.185 /* Master clock for generating 2 phase clock */
#define Teensy_MHz 600 /* for Teensy 4.1 */

#define count_to_ns(x) ((x)*1000/Teensy_Mhz)
#define ns_to_count(x) ((x)*Teensy_MHz/1000)

#define MCLK_cnt (unsigned long)(Teensy_MHz / MCLK_MHz)
#define MCLK_cnt_offset (unsigned long)12 /* 20.0ns@600Mhz */

#define GPIO_LED LED_BUILTIN
#define RESET 1

#define DOUT0  32 // output
#define DOUT1  31 // output
#define DOUT2  30 // output
#define DOUT3  29 // output
#define DOE    28 // output

#define DIN0   27 // input
#define DIN1   26 // input
#define DIN2   25 // input
#define DIN3   24 // input

#define SYNC   12 // input
#define CMROM  11 // input

#define CLK1    6 // output
#define CLK2    5 // output

#define digitalWrite digitalWriteFast
#define digitalRead digitalReadFast

// for Positive Logic
#define Assert(pin) digitalWrite(pin, 1)
#define Negate(pin) digitalWrite(pin, 0)

// for Negative Logic
#define Assert_N(pin) digitalWrite(pin, 0)
#define Negate_N(pin) digitalWrite(pin, 1)

// Global variables
int g_Phase = 0;
int g_Cycle = 0;

#define ROMSIZE 4096
byte g_ROM[ROMSIZE] = {
  0x2e, 0x00, 0x2f, 0xea, 0xe1, 0x19, 0x09, 0xf2,
  0xf2, 0xf8, 0xb4, 0x50, 0x10, 0xa4, 0x40, 0x04,
  0xea, 0xb3, 0x70, 0x12, 0x71, 0x12, 0x72, 0x12,
  0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00
};

#define Cycle_A1 0
#define Cycle_A2 1
#define Cycle_A3 2
#define Cycle_M1 3
#define Cycle_M2 4
#define Cycle_X1 5
#define Cycle_X2 6
#define Cycle_X3 7


inline void writeDataBus(byte data){
  // address/data line is negative logic
  data = ~data; 
  digitalWrite(DOUT0, data & bit(0));
  digitalWrite(DOUT1, data & bit(1));
  digitalWrite(DOUT2, data & bit(2));
  digitalWrite(DOUT3, data & bit(3));
  Assert(DOE);
}

inline byte readDataBus(){
  // address/data line is negative logic
  return ( (~(digitalRead(DIN0)
	      | (digitalRead(DIN1) << 1)
	      | (digitalRead(DIN2) << 2)
	      | (digitalRead(DIN3) << 3)
	      )) & 0x0f
	   );
}

void setPhase(int p){
  while(ARM_DWT_CYCCNT < MCLK_cnt){
  }
  ARM_DWT_CYCCNT = MCLK_cnt_offset; /* reset counter with compensation */

  // (2 phase clocks are generated by 7th-counter)
  //      6    0    1    2    3    4    5    6    0
  // CLK1 ~~~~~\_________/~~~~~~~~~~~~~~~~~~~~~~~~\____
  //
  // CLK2 /~~~~~~~~~~~~~~~~~~~~~~~~\_________/~~~~~~~~~
  switch(p){
  case 0: Negate(CLK1); break;
  case 2: Assert(CLK1); break;
  case 4: Negate(CLK2); break;
  case 6: Assert(CLK2); break;
  }
}


void setup() {
  // noInterrupts(); // Disable interrupts
  
  // for clock counter
  ARM_DEMCR |= ARM_DEMCR_TRCENA;
  ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA;

  pinMode(GPIO_LED, OUTPUT); Negate(GPIO_LED);
  pinMode(RESET, INPUT_PULLUP);
  
  pinMode(DOUT0, OUTPUT);
  pinMode(DOUT1, OUTPUT);
  pinMode(DOUT2, OUTPUT);
  pinMode(DOUT3, OUTPUT);
  pinMode(DOE,   OUTPUT);  Negate(DOE);
  pinMode(DIN0,  INPUT);
  pinMode(DIN1,  INPUT);
  pinMode(DIN2,  INPUT);
  pinMode(DIN3,  INPUT);

  pinMode(SYNC,  INPUT);
  pinMode(CMROM, INPUT);
  pinMode(CLK1,  OUTPUT);
  pinMode(CLK2,  OUTPUT);
}

void loop() {
  word address = 0;
  bool access_rom = false;
  int cycle = Cycle_X3;
  
  ARM_DWT_CYCCNT = 0; /* reset counter */
  while(1){
    setPhase(0); /* Phase 0 */
    Negate(DOE);
    setPhase(1); /* Phase 1 */
    setPhase(2); /* Phase 2 */
    setPhase(3); /* Phase 3 */
    if(access_rom){
      if(cycle == Cycle_M1){
	writeDataBus(g_ROM[address&(ROMSIZE-1)] >> 4);
      } else if(cycle == Cycle_M2){
	writeDataBus(g_ROM[address&(ROMSIZE-1)]);
      }
    }
    setPhase(4); /* Phase 4 */
    setPhase(5); /* Phase 5 */
    if(cycle == Cycle_A3 && digitalRead(CMROM) == 0){
      /* CMROM is negative logic */
      access_rom = true;
    }
    setPhase(6); /* Phase 6 */
    if(cycle == Cycle_A1){
      address = readDataBus();
    } else if(cycle == Cycle_A2){
      address |= (readDataBus() << 4);
    } else if(cycle == Cycle_A3){
      address |= (readDataBus() << 8);
    }
    if(digitalRead(SYNC) == 0){ /* SYNC is negative logic */
      cycle = Cycle_A1;
      access_rom = false;
    } else {
      cycle++;
      if(cycle > Cycle_X3){
	cycle = Cycle_X3;
      }
    }
  }  
}
